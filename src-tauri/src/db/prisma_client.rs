// Code generated by Prisma Client Rust. DO NOT EDIT

pub static DATAMODEL_STR: &'static str =
    include_str!("E:\\Workspace\\nodejs\\openchat\\src-tauri\\prisma\\schema.prisma");
static DATABASE_STR: &'static str = "sqlite";
use ::prisma_client_rust::migrations::include_dir;
pub static MIGRATIONS_DIR: &::prisma_client_rust::migrations::include_dir::Dir = &::prisma_client_rust::migrations::include_dir::include_dir!(
    "E:\\Workspace\\nodejs\\openchat\\src-tauri\\prisma\\migrations"
);
pub async fn new_client() -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder().build().await
}
pub async fn new_client_with_url(
    url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder()
        .with_url(url.to_string())
        .build()
        .await
}
pub mod prompt {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "Prompt";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod title {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "title";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTitle(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Title(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Title(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Title(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Title,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Title(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Title(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod desc {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "desc";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDesc(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Desc(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Desc(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Desc(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Desc, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Desc(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Desc(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod system {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "system";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetSystem(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::System(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::System(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::System(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            System,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::System(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::System(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod favorite {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "favorite";
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetFavorite(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Favorite(v)
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Favorite(direction)
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::Favorite(_prisma::read_filters::BoolFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BoolFilter,
            Favorite,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Favorite(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Favorite(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod actived {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "actived";
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetActived(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Actived(v)
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Actived(direction)
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::Actived(_prisma::read_filters::BoolFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BoolFilter,
            Actived,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Actived(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Actived(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod with_context {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "with_context";
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetWithContext(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::WithContext(v)
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::WithContext(direction)
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::WithContext(_prisma::read_filters::BoolFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BoolFilter,
            WithContext,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::WithContext(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::WithContext(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod with_context_size {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "with_context_size";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetWithContextSize(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::WithContextSize(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::WithContextSize(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::WithContextSize(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            WithContextSize,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementWithContextSize(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementWithContextSize(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyWithContextSize(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideWithContextSize(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::WithContextSize(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::WithContextSize(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod max_tokens {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "max_tokens";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetMaxTokens(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::MaxTokens(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::MaxTokens(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::MaxTokens(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            MaxTokens,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementMaxTokens(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementMaxTokens(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyMaxTokens(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideMaxTokens(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::MaxTokens(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::MaxTokens(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod top_p {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "top_p";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTopP(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::TopP(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::TopP(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::TopP(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, TopP, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::TopP(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::TopP(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod temperature {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "temperature";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTemperature(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Temperature(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Temperature(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Temperature(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Temperature,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Temperature(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Temperature(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod opts {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "opts";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetOpts(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Opts(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Opts(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Opts(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Opts, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Opts(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Opts(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod prehandle_script {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "prehandle_script";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPrehandleScript(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::PrehandleScript(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::PrehandleScript(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::PrehandleScript(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            PrehandleScript,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::PrehandleScript(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::PrehandleScript(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod labels {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "labels";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetLabels(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Labels(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Labels(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Labels(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Labels,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Labels(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Labels(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod updated_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "updated_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetUpdatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::UpdatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UpdatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::UpdatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            UpdatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UpdatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UpdatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub fn create(
        title: String,
        desc: String,
        system: String,
        favorite: bool,
        actived: bool,
        with_context: bool,
        with_context_size: i32,
        max_tokens: i32,
        top_p: String,
        temperature: String,
        opts: String,
        prehandle_script: String,
        labels: String,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        String,
        bool,
        bool,
        bool,
        i32,
        i32,
        String,
        String,
        String,
        String,
        String,
        Vec<SetParam>,
    ) {
        (
            title,
            desc,
            system,
            favorite,
            actived,
            with_context,
            with_context_size,
            max_tokens,
            top_p,
            temperature,
            opts,
            prehandle_script,
            labels,
            _params,
        )
    }
    pub fn create_unchecked(
        title: String,
        desc: String,
        system: String,
        favorite: bool,
        actived: bool,
        with_context: bool,
        with_context_size: i32,
        max_tokens: i32,
        top_p: String,
        temperature: String,
        opts: String,
        prehandle_script: String,
        labels: String,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        String,
        bool,
        bool,
        bool,
        i32,
        i32,
        String,
        String,
        String,
        String,
        String,
        Vec<SetParam>,
    ) {
        (
            title,
            desc,
            system,
            favorite,
            actived,
            with_context,
            with_context_size,
            max_tokens,
            top_p,
            temperature,
            opts,
            prehandle_script,
            labels,
            _params,
        )
    }
    #[macro_export]
    macro_rules ! _select_prompt { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: crate :: db :: prisma_client :: prompt :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: crate :: db :: prisma_client :: prompt :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: crate :: db :: prisma_client :: prompt :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: crate :: db :: prisma_client :: prompt :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: crate :: db :: prisma_client :: prompt :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: crate :: db :: prisma_client :: prompt :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , title , desc , system , favorite , actived , with_context , with_context_size , max_tokens , top_p , temperature , opts , prehandle_script , labels , created_at , updated_at } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: crate :: db :: prisma_client :: prompt :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: crate :: db :: prisma_client :: prompt :: $ field :: NAME)] pub $ field : crate :: crate :: db :: prisma_client :: prompt :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: crate :: db :: prisma_client :: prompt :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: crate :: db :: prisma_client :: prompt :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: crate :: db :: prisma_client :: prompt :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: prompt :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: prompt :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "title" , "desc" , "system" , "favorite" , "actived" , "with_context" , "with_context_size" , "max_tokens" , "top_p" , "temperature" , "opts" , "prehandle_script" , "labels" , "created_at" , "updated_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: crate :: db :: prisma_client :: prompt :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; title) => { String } ; (@ field_type ; desc) => { String } ; (@ field_type ; system) => { String } ; (@ field_type ; favorite) => { bool } ; (@ field_type ; actived) => { bool } ; (@ field_type ; with_context) => { bool } ; (@ field_type ; with_context_size) => { i32 } ; (@ field_type ; max_tokens) => { i32 } ; (@ field_type ; top_p) => { String } ; (@ field_type ; temperature) => { String } ; (@ field_type ; opts) => { String } ; (@ field_type ; prehandle_script) => { String } ; (@ field_type ; labels) => { String } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; updated_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Prompt" , available relations are "id, title, desc, system, favorite, actived, with_context, with_context_size, max_tokens, top_p, temperature, opts, prehandle_script, labels, created_at, updated_at")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: crate :: db :: prisma_client :: prompt :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: prompt :: id :: Select) } ; (@ selection_field_to_selection_param ; title) => { Into :: < crate :: crate :: db :: prisma_client :: prompt :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: prompt :: title :: Select) } ; (@ selection_field_to_selection_param ; desc) => { Into :: < crate :: crate :: db :: prisma_client :: prompt :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: prompt :: desc :: Select) } ; (@ selection_field_to_selection_param ; system) => { Into :: < crate :: crate :: db :: prisma_client :: prompt :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: prompt :: system :: Select) } ; (@ selection_field_to_selection_param ; favorite) => { Into :: < crate :: crate :: db :: prisma_client :: prompt :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: prompt :: favorite :: Select) } ; (@ selection_field_to_selection_param ; actived) => { Into :: < crate :: crate :: db :: prisma_client :: prompt :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: prompt :: actived :: Select) } ; (@ selection_field_to_selection_param ; with_context) => { Into :: < crate :: crate :: db :: prisma_client :: prompt :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: prompt :: with_context :: Select) } ; (@ selection_field_to_selection_param ; with_context_size) => { Into :: < crate :: crate :: db :: prisma_client :: prompt :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: prompt :: with_context_size :: Select) } ; (@ selection_field_to_selection_param ; max_tokens) => { Into :: < crate :: crate :: db :: prisma_client :: prompt :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: prompt :: max_tokens :: Select) } ; (@ selection_field_to_selection_param ; top_p) => { Into :: < crate :: crate :: db :: prisma_client :: prompt :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: prompt :: top_p :: Select) } ; (@ selection_field_to_selection_param ; temperature) => { Into :: < crate :: crate :: db :: prisma_client :: prompt :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: prompt :: temperature :: Select) } ; (@ selection_field_to_selection_param ; opts) => { Into :: < crate :: crate :: db :: prisma_client :: prompt :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: prompt :: opts :: Select) } ; (@ selection_field_to_selection_param ; prehandle_script) => { Into :: < crate :: crate :: db :: prisma_client :: prompt :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: prompt :: prehandle_script :: Select) } ; (@ selection_field_to_selection_param ; labels) => { Into :: < crate :: crate :: db :: prisma_client :: prompt :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: prompt :: labels :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: crate :: db :: prisma_client :: prompt :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: prompt :: created_at :: Select) } ; (@ selection_field_to_selection_param ; updated_at) => { Into :: < crate :: crate :: db :: prisma_client :: prompt :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: prompt :: updated_at :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: crate :: db :: prisma_client :: prompt :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; desc) => { "desc" } ; (@ field_serde_name ; system) => { "system" } ; (@ field_serde_name ; favorite) => { "favorite" } ; (@ field_serde_name ; actived) => { "actived" } ; (@ field_serde_name ; with_context) => { "with_context" } ; (@ field_serde_name ; with_context_size) => { "with_context_size" } ; (@ field_serde_name ; max_tokens) => { "max_tokens" } ; (@ field_serde_name ; top_p) => { "top_p" } ; (@ field_serde_name ; temperature) => { "temperature" } ; (@ field_serde_name ; opts) => { "opts" } ; (@ field_serde_name ; prehandle_script) => { "prehandle_script" } ; (@ field_serde_name ; labels) => { "labels" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; updated_at) => { "updated_at" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
    pub use _select_prompt as select;
    pub enum SelectParam {
        Id(id::Select),
        Title(title::Select),
        Desc(desc::Select),
        System(system::Select),
        Favorite(favorite::Select),
        Actived(actived::Select),
        WithContext(with_context::Select),
        WithContextSize(with_context_size::Select),
        MaxTokens(max_tokens::Select),
        TopP(top_p::Select),
        Temperature(temperature::Select),
        Opts(opts::Select),
        PrehandleScript(prehandle_script::Select),
        Labels(labels::Select),
        CreatedAt(created_at::Select),
        UpdatedAt(updated_at::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Title(data) => data.to_selection(),
                Self::Desc(data) => data.to_selection(),
                Self::System(data) => data.to_selection(),
                Self::Favorite(data) => data.to_selection(),
                Self::Actived(data) => data.to_selection(),
                Self::WithContext(data) => data.to_selection(),
                Self::WithContextSize(data) => data.to_selection(),
                Self::MaxTokens(data) => data.to_selection(),
                Self::TopP(data) => data.to_selection(),
                Self::Temperature(data) => data.to_selection(),
                Self::Opts(data) => data.to_selection(),
                Self::PrehandleScript(data) => data.to_selection(),
                Self::Labels(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::UpdatedAt(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_prompt { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: crate :: db :: prisma_client :: prompt :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: crate :: db :: prisma_client :: prompt :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: crate :: db :: prisma_client :: prompt :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: crate :: db :: prisma_client :: prompt :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: crate :: db :: prisma_client :: prompt :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: crate :: db :: prisma_client :: prompt :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: crate :: db :: prisma_client :: prompt :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: crate :: db :: prisma_client :: prompt :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: crate :: db :: prisma_client :: prompt :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: prompt :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: prompt :: title :: NAME)] pub title : String , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: prompt :: desc :: NAME)] pub desc : String , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: prompt :: system :: NAME)] pub system : String , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: prompt :: favorite :: NAME)] pub favorite : bool , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: prompt :: actived :: NAME)] pub actived : bool , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: prompt :: with_context :: NAME)] pub with_context : bool , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: prompt :: with_context_size :: NAME)] pub with_context_size : i32 , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: prompt :: max_tokens :: NAME)] pub max_tokens : i32 , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: prompt :: top_p :: NAME)] pub top_p : String , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: prompt :: temperature :: NAME)] pub temperature : String , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: prompt :: opts :: NAME)] pub opts : String , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: prompt :: prehandle_script :: NAME)] pub prehandle_script : String , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: prompt :: labels :: NAME)] pub labels : String , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: prompt :: created_at :: NAME)] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: prompt :: updated_at :: NAME)] pub updated_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (# [specta (rename_from_path = crate :: crate :: db :: prisma_client :: prompt :: $ field :: NAME)] pub $ field : crate :: crate :: db :: prisma_client :: prompt :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (title) , stringify ! (desc) , stringify ! (system) , stringify ! (favorite) , stringify ! (actived) , stringify ! (with_context) , stringify ! (with_context_size) , stringify ! (max_tokens) , stringify ! (top_p) , stringify ! (temperature) , stringify ! (opts) , stringify ! (prehandle_script) , stringify ! (labels) , stringify ! (created_at) , stringify ! (updated_at)] . len ()) ? ; $ (state . serialize_field (crate :: crate :: db :: prisma_client :: prompt :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: crate :: db :: prisma_client :: prompt :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: prompt :: title :: NAME , & self . title) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: prompt :: desc :: NAME , & self . desc) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: prompt :: system :: NAME , & self . system) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: prompt :: favorite :: NAME , & self . favorite) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: prompt :: actived :: NAME , & self . actived) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: prompt :: with_context :: NAME , & self . with_context) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: prompt :: with_context_size :: NAME , & self . with_context_size) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: prompt :: max_tokens :: NAME , & self . max_tokens) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: prompt :: top_p :: NAME , & self . top_p) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: prompt :: temperature :: NAME , & self . temperature) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: prompt :: opts :: NAME , & self . opts) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: prompt :: prehandle_script :: NAME , & self . prehandle_script) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: prompt :: labels :: NAME , & self . labels) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: prompt :: created_at :: NAME , & self . created_at) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: prompt :: updated_at :: NAME , & self . updated_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , title , desc , system , favorite , actived , with_context , with_context_size , max_tokens , top_p , temperature , opts , prehandle_script , labels , created_at , updated_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: crate :: db :: prisma_client :: prompt :: $ field :: NAME) , + , crate :: crate :: db :: prisma_client :: prompt :: id :: NAME , crate :: crate :: db :: prisma_client :: prompt :: title :: NAME , crate :: crate :: db :: prisma_client :: prompt :: desc :: NAME , crate :: crate :: db :: prisma_client :: prompt :: system :: NAME , crate :: crate :: db :: prisma_client :: prompt :: favorite :: NAME , crate :: crate :: db :: prisma_client :: prompt :: actived :: NAME , crate :: crate :: db :: prisma_client :: prompt :: with_context :: NAME , crate :: crate :: db :: prisma_client :: prompt :: with_context_size :: NAME , crate :: crate :: db :: prisma_client :: prompt :: max_tokens :: NAME , crate :: crate :: db :: prisma_client :: prompt :: top_p :: NAME , crate :: crate :: db :: prisma_client :: prompt :: temperature :: NAME , crate :: crate :: db :: prisma_client :: prompt :: opts :: NAME , crate :: crate :: db :: prisma_client :: prompt :: prehandle_script :: NAME , crate :: crate :: db :: prisma_client :: prompt :: labels :: NAME , crate :: crate :: db :: prisma_client :: prompt :: created_at :: NAME , crate :: crate :: db :: prisma_client :: prompt :: updated_at :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: crate :: db :: prisma_client :: prompt :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: crate :: db :: prisma_client :: prompt :: id :: NAME => Ok (Field :: id) , crate :: crate :: db :: prisma_client :: prompt :: title :: NAME => Ok (Field :: title) , crate :: crate :: db :: prisma_client :: prompt :: desc :: NAME => Ok (Field :: desc) , crate :: crate :: db :: prisma_client :: prompt :: system :: NAME => Ok (Field :: system) , crate :: crate :: db :: prisma_client :: prompt :: favorite :: NAME => Ok (Field :: favorite) , crate :: crate :: db :: prisma_client :: prompt :: actived :: NAME => Ok (Field :: actived) , crate :: crate :: db :: prisma_client :: prompt :: with_context :: NAME => Ok (Field :: with_context) , crate :: crate :: db :: prisma_client :: prompt :: with_context_size :: NAME => Ok (Field :: with_context_size) , crate :: crate :: db :: prisma_client :: prompt :: max_tokens :: NAME => Ok (Field :: max_tokens) , crate :: crate :: db :: prisma_client :: prompt :: top_p :: NAME => Ok (Field :: top_p) , crate :: crate :: db :: prisma_client :: prompt :: temperature :: NAME => Ok (Field :: temperature) , crate :: crate :: db :: prisma_client :: prompt :: opts :: NAME => Ok (Field :: opts) , crate :: crate :: db :: prisma_client :: prompt :: prehandle_script :: NAME => Ok (Field :: prehandle_script) , crate :: crate :: db :: prisma_client :: prompt :: labels :: NAME => Ok (Field :: labels) , crate :: crate :: db :: prisma_client :: prompt :: created_at :: NAME => Ok (Field :: created_at) , crate :: crate :: db :: prisma_client :: prompt :: updated_at :: NAME => Ok (Field :: updated_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut title = None ; let mut desc = None ; let mut system = None ; let mut favorite = None ; let mut actived = None ; let mut with_context = None ; let mut with_context_size = None ; let mut max_tokens = None ; let mut top_p = None ; let mut temperature = None ; let mut opts = None ; let mut prehandle_script = None ; let mut labels = None ; let mut created_at = None ; let mut updated_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: prompt :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: title => { if title . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: prompt :: title :: NAME)) ; } title = Some (map . next_value () ?) ; } Field :: desc => { if desc . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: prompt :: desc :: NAME)) ; } desc = Some (map . next_value () ?) ; } Field :: system => { if system . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: prompt :: system :: NAME)) ; } system = Some (map . next_value () ?) ; } Field :: favorite => { if favorite . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: prompt :: favorite :: NAME)) ; } favorite = Some (map . next_value () ?) ; } Field :: actived => { if actived . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: prompt :: actived :: NAME)) ; } actived = Some (map . next_value () ?) ; } Field :: with_context => { if with_context . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: prompt :: with_context :: NAME)) ; } with_context = Some (map . next_value () ?) ; } Field :: with_context_size => { if with_context_size . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: prompt :: with_context_size :: NAME)) ; } with_context_size = Some (map . next_value () ?) ; } Field :: max_tokens => { if max_tokens . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: prompt :: max_tokens :: NAME)) ; } max_tokens = Some (map . next_value () ?) ; } Field :: top_p => { if top_p . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: prompt :: top_p :: NAME)) ; } top_p = Some (map . next_value () ?) ; } Field :: temperature => { if temperature . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: prompt :: temperature :: NAME)) ; } temperature = Some (map . next_value () ?) ; } Field :: opts => { if opts . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: prompt :: opts :: NAME)) ; } opts = Some (map . next_value () ?) ; } Field :: prehandle_script => { if prehandle_script . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: prompt :: prehandle_script :: NAME)) ; } prehandle_script = Some (map . next_value () ?) ; } Field :: labels => { if labels . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: prompt :: labels :: NAME)) ; } labels = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: prompt :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } Field :: updated_at => { if updated_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: prompt :: updated_at :: NAME)) ; } updated_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: prompt :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: prompt :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: prompt :: id :: NAME)) ? ; let title = title . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: prompt :: title :: NAME)) ? ; let desc = desc . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: prompt :: desc :: NAME)) ? ; let system = system . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: prompt :: system :: NAME)) ? ; let favorite = favorite . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: prompt :: favorite :: NAME)) ? ; let actived = actived . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: prompt :: actived :: NAME)) ? ; let with_context = with_context . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: prompt :: with_context :: NAME)) ? ; let with_context_size = with_context_size . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: prompt :: with_context_size :: NAME)) ? ; let max_tokens = max_tokens . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: prompt :: max_tokens :: NAME)) ? ; let top_p = top_p . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: prompt :: top_p :: NAME)) ? ; let temperature = temperature . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: prompt :: temperature :: NAME)) ? ; let opts = opts . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: prompt :: opts :: NAME)) ? ; let prehandle_script = prehandle_script . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: prompt :: prehandle_script :: NAME)) ? ; let labels = labels . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: prompt :: labels :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: prompt :: created_at :: NAME)) ? ; let updated_at = updated_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: prompt :: updated_at :: NAME)) ? ; Ok (Data { id , title , desc , system , favorite , actived , with_context , with_context_size , max_tokens , top_p , temperature , opts , prehandle_script , labels , created_at , updated_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "title" , "desc" , "system" , "favorite" , "actived" , "with_context" , "with_context_size" , "max_tokens" , "top_p" , "temperature" , "opts" , "prehandle_script" , "labels" , "created_at" , "updated_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: crate :: db :: prisma_client :: prompt :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Prompt" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: crate :: db :: prisma_client :: prompt :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; desc) => { "desc" } ; (@ field_serde_name ; system) => { "system" } ; (@ field_serde_name ; favorite) => { "favorite" } ; (@ field_serde_name ; actived) => { "actived" } ; (@ field_serde_name ; with_context) => { "with_context" } ; (@ field_serde_name ; with_context_size) => { "with_context_size" } ; (@ field_serde_name ; max_tokens) => { "max_tokens" } ; (@ field_serde_name ; top_p) => { "top_p" } ; (@ field_serde_name ; temperature) => { "temperature" } ; (@ field_serde_name ; opts) => { "opts" } ; (@ field_serde_name ; prehandle_script) => { "prehandle_script" } ; (@ field_serde_name ; labels) => { "labels" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; updated_at) => { "updated_at" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
    pub use _include_prompt as include;
    pub enum IncludeParam {
        Id(id::Include),
        Title(title::Include),
        Desc(desc::Include),
        System(system::Include),
        Favorite(favorite::Include),
        Actived(actived::Include),
        WithContext(with_context::Include),
        WithContextSize(with_context_size::Include),
        MaxTokens(max_tokens::Include),
        TopP(top_p::Include),
        Temperature(temperature::Include),
        Opts(opts::Include),
        PrehandleScript(prehandle_script::Include),
        Labels(labels::Include),
        CreatedAt(created_at::Include),
        UpdatedAt(updated_at::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Title(data) => data.to_selection(),
                Self::Desc(data) => data.to_selection(),
                Self::System(data) => data.to_selection(),
                Self::Favorite(data) => data.to_selection(),
                Self::Actived(data) => data.to_selection(),
                Self::WithContext(data) => data.to_selection(),
                Self::WithContextSize(data) => data.to_selection(),
                Self::MaxTokens(data) => data.to_selection(),
                Self::TopP(data) => data.to_selection(),
                Self::Temperature(data) => data.to_selection(),
                Self::Opts(data) => data.to_selection(),
                Self::PrehandleScript(data) => data.to_selection(),
                Self::Labels(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::UpdatedAt(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_prompt { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: crate :: db :: prisma_client :: prompt struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "title")] pub title : String , # [serde (rename = "desc")] pub desc : String , # [serde (rename = "system")] pub system : String , # [serde (rename = "favorite")] pub favorite : bool , # [serde (rename = "actived")] pub actived : bool , # [serde (rename = "with_context")] pub with_context : bool , # [serde (rename = "with_context_size")] pub with_context_size : i32 , # [serde (rename = "max_tokens")] pub max_tokens : i32 , # [serde (rename = "top_p")] pub top_p : String , # [serde (rename = "temperature")] pub temperature : String , # [serde (rename = "opts")] pub opts : String , # [serde (rename = "prehandle_script")] pub prehandle_script : String , # [serde (rename = "labels")] pub labels : String , # [serde (rename = "created_at")] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "updated_at")] pub updated_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_prompt as partial_unchecked;
    #[derive(
        Debug,
        Clone,
        :: serde :: Serialize,
        :: serde :: Deserialize,
        :: prisma_client_rust :: specta :: Type,
    )]
    #[specta(rename = "Prompt", crate = "prisma_client_rust::specta")]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "title")]
        pub title: String,
        #[serde(rename = "desc")]
        pub desc: String,
        #[serde(rename = "system")]
        pub system: String,
        #[serde(rename = "favorite")]
        pub favorite: bool,
        #[serde(rename = "actived")]
        pub actived: bool,
        #[serde(rename = "with_context")]
        pub with_context: bool,
        #[serde(rename = "with_context_size")]
        pub with_context_size: i32,
        #[serde(rename = "max_tokens")]
        pub max_tokens: i32,
        #[serde(rename = "top_p")]
        pub top_p: String,
        #[serde(rename = "temperature")]
        pub temperature: String,
        #[serde(rename = "opts")]
        pub opts: String,
        #[serde(rename = "prehandle_script")]
        pub prehandle_script: String,
        #[serde(rename = "labels")]
        pub labels: String,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "updated_at")]
        pub updated_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetTitle(String),
        SetDesc(String),
        SetSystem(String),
        SetFavorite(bool),
        SetActived(bool),
        SetWithContext(bool),
        SetWithContextSize(i32),
        IncrementWithContextSize(i32),
        DecrementWithContextSize(i32),
        MultiplyWithContextSize(i32),
        DivideWithContextSize(i32),
        SetMaxTokens(i32),
        IncrementMaxTokens(i32),
        DecrementMaxTokens(i32),
        MultiplyMaxTokens(i32),
        DivideMaxTokens(i32),
        SetTopP(String),
        SetTemperature(String),
        SetOpts(String),
        SetPrehandleScript(String),
        SetLabels(String),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetUpdatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetTitle(value) => (
                    title::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetDesc(value) => (
                    desc::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetSystem(value) => (
                    system::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetFavorite(value) => (
                    favorite::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetActived(value) => (
                    actived::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetWithContext(value) => (
                    with_context::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetWithContextSize(value) => (
                    with_context_size::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementWithContextSize(value) => (
                    with_context_size::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementWithContextSize(value) => (
                    with_context_size::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyWithContextSize(value) => (
                    with_context_size::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideWithContextSize(value) => (
                    with_context_size::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetMaxTokens(value) => (
                    max_tokens::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementMaxTokens(value) => (
                    max_tokens::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementMaxTokens(value) => (
                    max_tokens::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyMaxTokens(value) => (
                    max_tokens::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideMaxTokens(value) => (
                    max_tokens::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetTopP(value) => (
                    top_p::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetTemperature(value) => (
                    temperature::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetOpts(value) => (
                    opts::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetPrehandleScript(value) => (
                    prehandle_script::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetLabels(value) => (
                    labels::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetUpdatedAt(value) => (
                    updated_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        Title(String),
        Desc(String),
        System(String),
        Favorite(bool),
        Actived(bool),
        WithContext(bool),
        WithContextSize(i32),
        MaxTokens(i32),
        TopP(String),
        Temperature(String),
        Opts(String),
        PrehandleScript(String),
        Labels(String),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        UpdatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::Title(value) => Self::SetTitle(value),
                UncheckedSetParam::Desc(value) => Self::SetDesc(value),
                UncheckedSetParam::System(value) => Self::SetSystem(value),
                UncheckedSetParam::Favorite(value) => Self::SetFavorite(value),
                UncheckedSetParam::Actived(value) => Self::SetActived(value),
                UncheckedSetParam::WithContext(value) => Self::SetWithContext(value),
                UncheckedSetParam::WithContextSize(value) => Self::SetWithContextSize(value),
                UncheckedSetParam::MaxTokens(value) => Self::SetMaxTokens(value),
                UncheckedSetParam::TopP(value) => Self::SetTopP(value),
                UncheckedSetParam::Temperature(value) => Self::SetTemperature(value),
                UncheckedSetParam::Opts(value) => Self::SetOpts(value),
                UncheckedSetParam::PrehandleScript(value) => Self::SetPrehandleScript(value),
                UncheckedSetParam::Labels(value) => Self::SetLabels(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
                UncheckedSetParam::UpdatedAt(value) => Self::SetUpdatedAt(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Title(::prisma_client_rust::Direction),
        Desc(::prisma_client_rust::Direction),
        System(::prisma_client_rust::Direction),
        Favorite(::prisma_client_rust::Direction),
        Actived(::prisma_client_rust::Direction),
        WithContext(::prisma_client_rust::Direction),
        WithContextSize(::prisma_client_rust::Direction),
        MaxTokens(::prisma_client_rust::Direction),
        TopP(::prisma_client_rust::Direction),
        Temperature(::prisma_client_rust::Direction),
        Opts(::prisma_client_rust::Direction),
        PrehandleScript(::prisma_client_rust::Direction),
        Labels(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        UpdatedAt(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Title(direction) => (
                    title::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Desc(direction) => (
                    desc::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::System(direction) => (
                    system::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Favorite(direction) => (
                    favorite::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Actived(direction) => (
                    actived::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::WithContext(direction) => (
                    with_context::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::WithContextSize(direction) => (
                    with_context_size::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::MaxTokens(direction) => (
                    max_tokens::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::TopP(direction) => (
                    top_p::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Temperature(direction) => (
                    temperature::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Opts(direction) => (
                    opts::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::PrehandleScript(direction) => (
                    prehandle_script::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Labels(direction) => (
                    labels::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::UpdatedAt(direction) => (
                    updated_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        Title(_prisma::read_filters::StringFilter),
        Desc(_prisma::read_filters::StringFilter),
        System(_prisma::read_filters::StringFilter),
        Favorite(_prisma::read_filters::BoolFilter),
        Actived(_prisma::read_filters::BoolFilter),
        WithContext(_prisma::read_filters::BoolFilter),
        WithContextSize(_prisma::read_filters::IntFilter),
        MaxTokens(_prisma::read_filters::IntFilter),
        TopP(_prisma::read_filters::StringFilter),
        Temperature(_prisma::read_filters::StringFilter),
        Opts(_prisma::read_filters::StringFilter),
        PrehandleScript(_prisma::read_filters::StringFilter),
        Labels(_prisma::read_filters::StringFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        UpdatedAt(_prisma::read_filters::DateTimeFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Title(value) => (title::NAME, value.into()),
                Self::Desc(value) => (desc::NAME, value.into()),
                Self::System(value) => (system::NAME, value.into()),
                Self::Favorite(value) => (favorite::NAME, value.into()),
                Self::Actived(value) => (actived::NAME, value.into()),
                Self::WithContext(value) => (with_context::NAME, value.into()),
                Self::WithContextSize(value) => (with_context_size::NAME, value.into()),
                Self::MaxTokens(value) => (max_tokens::NAME, value.into()),
                Self::TopP(value) => (top_p::NAME, value.into()),
                Self::Temperature(value) => (temperature::NAME, value.into()),
                Self::Opts(value) => (opts::NAME, value.into()),
                Self::PrehandleScript(value) => (prehandle_script::NAME, value.into()),
                Self::Labels(value) => (labels::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
                Self::UpdatedAt(value) => (updated_at::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(title::NAME),
                ::prisma_client_rust::sel(desc::NAME),
                ::prisma_client_rust::sel(system::NAME),
                ::prisma_client_rust::sel(favorite::NAME),
                ::prisma_client_rust::sel(actived::NAME),
                ::prisma_client_rust::sel(with_context::NAME),
                ::prisma_client_rust::sel(with_context_size::NAME),
                ::prisma_client_rust::sel(max_tokens::NAME),
                ::prisma_client_rust::sel(top_p::NAME),
                ::prisma_client_rust::sel(temperature::NAME),
                ::prisma_client_rust::sel(opts::NAME),
                ::prisma_client_rust::sel(prehandle_script::NAME),
                ::prisma_client_rust::sel(labels::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
                ::prisma_client_rust::sel(updated_at::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            title: String,
            desc: String,
            system: String,
            favorite: bool,
            actived: bool,
            with_context: bool,
            with_context_size: i32,
            max_tokens: i32,
            top_p: String,
            temperature: String,
            opts: String,
            prehandle_script: String,
            labels: String,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                title::set(title),
                desc::set(desc),
                system::set(system),
                favorite::set(favorite),
                actived::set(actived),
                with_context::set(with_context),
                with_context_size::set(with_context_size),
                max_tokens::set(max_tokens),
                top_p::set(top_p),
                temperature::set(temperature),
                opts::set(opts),
                prehandle_script::set(prehandle_script),
                labels::set(labels),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            title: String,
            desc: String,
            system: String,
            favorite: bool,
            actived: bool,
            with_context: bool,
            with_context_size: i32,
            max_tokens: i32,
            top_p: String,
            temperature: String,
            opts: String,
            prehandle_script: String,
            labels: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                title::set(title),
                desc::set(desc),
                system::set(system),
                favorite::set(favorite),
                actived::set(actived),
                with_context::set(with_context),
                with_context_size::set(with_context_size),
                max_tokens::set(max_tokens),
                top_p::set(top_p),
                temperature::set(temperature),
                opts::set(opts),
                prehandle_script::set(prehandle_script),
                labels::set(labels),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (
                title,
                desc,
                system,
                favorite,
                actived,
                with_context,
                with_context_size,
                max_tokens,
                top_p,
                temperature,
                opts,
                prehandle_script,
                labels,
                mut _params,
            ): (
                String,
                String,
                String,
                bool,
                bool,
                bool,
                i32,
                i32,
                String,
                String,
                String,
                String,
                String,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                title::set(title),
                desc::set(desc),
                system::set(system),
                favorite::set(favorite),
                actived::set(actived),
                with_context::set(with_context),
                with_context_size::set(with_context_size),
                max_tokens::set(max_tokens),
                top_p::set(top_p),
                temperature::set(temperature),
                opts::set(opts),
                prehandle_script::set(prehandle_script),
                labels::set(labels),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod session_data {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "SessionData";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod session_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "session_id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetSessionId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::SessionId(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::SessionId(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::SessionId(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            SessionId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SessionId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SessionId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod role {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "role";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetRole(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Role(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Role(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Role(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Role, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Role(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Role(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod message {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "message";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetMessage(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Message(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Message(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Message(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Message,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Message(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Message(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod message_type {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "message_type";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetMessageType(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::MessageType(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::MessageType(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::MessageType(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            MessageType,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::MessageType(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::MessageType(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod session {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "session";
        pub struct Fetch(pub session::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<session::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Session(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(session::UniqueArgs::new())
        }
        pub struct Connect(session::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectSession(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: session::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectSession
        }
        pub fn is_null() -> WhereParam {
            WhereParam::SessionIsNull
        }
        pub fn is(value: Vec<session::WhereParam>) -> WhereParam {
            WhereParam::SessionIs(value)
        }
        pub fn is_not(value: Vec<session::WhereParam>) -> WhereParam {
            WhereParam::SessionIsNot(value)
        }
        pub enum Include {
            Select(Vec<session::SelectParam>),
            Include(Vec<session::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Session(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <session::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <session::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("session", None, [], selections)
            }
            pub fn select(nested_selections: Vec<session::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<session::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<session::SelectParam>),
            Include(Vec<session::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Session(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <session::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("session", None, [], selections)
            }
            pub fn select(nested_selections: Vec<session::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<session::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod updated_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "updated_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetUpdatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::UpdatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UpdatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::UpdatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            UpdatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UpdatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UpdatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub fn create(
        session_id: String,
        role: String,
        message: String,
        message_type: String,
        _params: Vec<SetParam>,
    ) -> (String, String, String, String, Vec<SetParam>) {
        (session_id, role, message, message_type, _params)
    }
    pub fn create_unchecked(
        session_id: String,
        role: String,
        message: String,
        message_type: String,
        _params: Vec<SetParam>,
    ) -> (String, String, String, String, Vec<SetParam>) {
        (session_id, role, message, message_type, _params)
    }
    #[macro_export]
    macro_rules ! _select_session_data { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: crate :: db :: prisma_client :: session_data :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: crate :: db :: prisma_client :: session_data :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: crate :: db :: prisma_client :: session_data :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: crate :: db :: prisma_client :: session_data :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: crate :: db :: prisma_client :: session_data :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: crate :: db :: prisma_client :: session_data :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , session_id , role , message , message_type , session , created_at , updated_at } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: crate :: db :: prisma_client :: session_data :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: crate :: db :: prisma_client :: session_data :: $ field :: NAME)] pub $ field : crate :: crate :: db :: prisma_client :: session_data :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: crate :: db :: prisma_client :: session_data :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: crate :: db :: prisma_client :: session_data :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: crate :: db :: prisma_client :: session_data :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: session_data :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: session_data :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "session_id" , "role" , "message" , "message_type" , "session" , "created_at" , "updated_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: crate :: db :: prisma_client :: session_data :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; session_id) => { String } ; (@ field_type ; role) => { String } ; (@ field_type ; message) => { String } ; (@ field_type ; message_type) => { String } ; (@ field_type ; session : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < session :: Data > } ; (@ field_type ; session) => { Option < crate :: crate :: db :: prisma_client :: session :: Data > } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; updated_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "SessionData" , available relations are "id, session_id, role, message, message_type, session, created_at, updated_at")) } ; (@ field_module ; session : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: crate :: db :: prisma_client :: session :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: crate :: db :: prisma_client :: session_data :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: session_data :: id :: Select) } ; (@ selection_field_to_selection_param ; session_id) => { Into :: < crate :: crate :: db :: prisma_client :: session_data :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: session_data :: session_id :: Select) } ; (@ selection_field_to_selection_param ; role) => { Into :: < crate :: crate :: db :: prisma_client :: session_data :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: session_data :: role :: Select) } ; (@ selection_field_to_selection_param ; message) => { Into :: < crate :: crate :: db :: prisma_client :: session_data :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: session_data :: message :: Select) } ; (@ selection_field_to_selection_param ; message_type) => { Into :: < crate :: crate :: db :: prisma_client :: session_data :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: session_data :: message_type :: Select) } ; (@ selection_field_to_selection_param ; session $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: crate :: db :: prisma_client :: session_data :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: session_data :: session :: Select :: $ selection_mode (crate :: crate :: db :: prisma_client :: session :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; session $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: crate :: db :: prisma_client :: session_data :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: session_data :: session :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: crate :: db :: prisma_client :: session_data :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: session_data :: created_at :: Select) } ; (@ selection_field_to_selection_param ; updated_at) => { Into :: < crate :: crate :: db :: prisma_client :: session_data :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: session_data :: updated_at :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: crate :: db :: prisma_client :: session_data :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; session_id) => { "session_id" } ; (@ field_serde_name ; role) => { "role" } ; (@ field_serde_name ; message) => { "message" } ; (@ field_serde_name ; message_type) => { "message_type" } ; (@ field_serde_name ; session) => { "session" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; updated_at) => { "updated_at" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
    pub use _select_session_data as select;
    pub enum SelectParam {
        Id(id::Select),
        SessionId(session_id::Select),
        Role(role::Select),
        Message(message::Select),
        MessageType(message_type::Select),
        Session(session::Select),
        CreatedAt(created_at::Select),
        UpdatedAt(updated_at::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::SessionId(data) => data.to_selection(),
                Self::Role(data) => data.to_selection(),
                Self::Message(data) => data.to_selection(),
                Self::MessageType(data) => data.to_selection(),
                Self::Session(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::UpdatedAt(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_session_data { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: crate :: db :: prisma_client :: session_data :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: crate :: db :: prisma_client :: session_data :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: crate :: db :: prisma_client :: session_data :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: crate :: db :: prisma_client :: session_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: crate :: db :: prisma_client :: session_data :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: crate :: db :: prisma_client :: session_data :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: crate :: db :: prisma_client :: session_data :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: crate :: db :: prisma_client :: session_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { session } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: crate :: db :: prisma_client :: session_data :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: session_data :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: session_data :: session_id :: NAME)] pub session_id : String , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: session_data :: role :: NAME)] pub role : String , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: session_data :: message :: NAME)] pub message : String , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: session_data :: message_type :: NAME)] pub message_type : String , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: session_data :: created_at :: NAME)] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: session_data :: updated_at :: NAME)] pub updated_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (# [specta (rename_from_path = crate :: crate :: db :: prisma_client :: session_data :: $ field :: NAME)] pub $ field : crate :: crate :: db :: prisma_client :: session_data :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (session_id) , stringify ! (role) , stringify ! (message) , stringify ! (message_type) , stringify ! (created_at) , stringify ! (updated_at)] . len ()) ? ; $ (state . serialize_field (crate :: crate :: db :: prisma_client :: session_data :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: crate :: db :: prisma_client :: session_data :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: session_data :: session_id :: NAME , & self . session_id) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: session_data :: role :: NAME , & self . role) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: session_data :: message :: NAME , & self . message) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: session_data :: message_type :: NAME , & self . message_type) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: session_data :: created_at :: NAME , & self . created_at) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: session_data :: updated_at :: NAME , & self . updated_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , session_id , role , message , message_type , created_at , updated_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: crate :: db :: prisma_client :: session_data :: $ field :: NAME) , + , crate :: crate :: db :: prisma_client :: session_data :: id :: NAME , crate :: crate :: db :: prisma_client :: session_data :: session_id :: NAME , crate :: crate :: db :: prisma_client :: session_data :: role :: NAME , crate :: crate :: db :: prisma_client :: session_data :: message :: NAME , crate :: crate :: db :: prisma_client :: session_data :: message_type :: NAME , crate :: crate :: db :: prisma_client :: session_data :: created_at :: NAME , crate :: crate :: db :: prisma_client :: session_data :: updated_at :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: crate :: db :: prisma_client :: session_data :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: crate :: db :: prisma_client :: session_data :: id :: NAME => Ok (Field :: id) , crate :: crate :: db :: prisma_client :: session_data :: session_id :: NAME => Ok (Field :: session_id) , crate :: crate :: db :: prisma_client :: session_data :: role :: NAME => Ok (Field :: role) , crate :: crate :: db :: prisma_client :: session_data :: message :: NAME => Ok (Field :: message) , crate :: crate :: db :: prisma_client :: session_data :: message_type :: NAME => Ok (Field :: message_type) , crate :: crate :: db :: prisma_client :: session_data :: created_at :: NAME => Ok (Field :: created_at) , crate :: crate :: db :: prisma_client :: session_data :: updated_at :: NAME => Ok (Field :: updated_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut session_id = None ; let mut role = None ; let mut message = None ; let mut message_type = None ; let mut created_at = None ; let mut updated_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: session_data :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: session_id => { if session_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: session_data :: session_id :: NAME)) ; } session_id = Some (map . next_value () ?) ; } Field :: role => { if role . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: session_data :: role :: NAME)) ; } role = Some (map . next_value () ?) ; } Field :: message => { if message . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: session_data :: message :: NAME)) ; } message = Some (map . next_value () ?) ; } Field :: message_type => { if message_type . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: session_data :: message_type :: NAME)) ; } message_type = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: session_data :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } Field :: updated_at => { if updated_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: session_data :: updated_at :: NAME)) ; } updated_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: session_data :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: session_data :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: session_data :: id :: NAME)) ? ; let session_id = session_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: session_data :: session_id :: NAME)) ? ; let role = role . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: session_data :: role :: NAME)) ? ; let message = message . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: session_data :: message :: NAME)) ? ; let message_type = message_type . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: session_data :: message_type :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: session_data :: created_at :: NAME)) ? ; let updated_at = updated_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: session_data :: updated_at :: NAME)) ? ; Ok (Data { id , session_id , role , message , message_type , created_at , updated_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "session_id" , "role" , "message" , "message_type" , "session" , "created_at" , "updated_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: crate :: db :: prisma_client :: session_data :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; session : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < session :: Data > } ; (@ field_type ; session) => { Option < crate :: crate :: db :: prisma_client :: session :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "SessionData" , available relations are "session")) } ; (@ field_module ; session : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: crate :: db :: prisma_client :: session :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; session $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: crate :: db :: prisma_client :: session_data :: IncludeParam > :: into (crate :: crate :: db :: prisma_client :: session_data :: session :: Include :: $ selection_mode (crate :: crate :: db :: prisma_client :: session :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; session $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: crate :: db :: prisma_client :: session_data :: IncludeParam > :: into (crate :: crate :: db :: prisma_client :: session_data :: session :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: crate :: db :: prisma_client :: session_data :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; session_id) => { "session_id" } ; (@ field_serde_name ; role) => { "role" } ; (@ field_serde_name ; message) => { "message" } ; (@ field_serde_name ; message_type) => { "message_type" } ; (@ field_serde_name ; session) => { "session" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; updated_at) => { "updated_at" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
    pub use _include_session_data as include;
    pub enum IncludeParam {
        Id(id::Include),
        SessionId(session_id::Include),
        Role(role::Include),
        Message(message::Include),
        MessageType(message_type::Include),
        Session(session::Include),
        CreatedAt(created_at::Include),
        UpdatedAt(updated_at::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::SessionId(data) => data.to_selection(),
                Self::Role(data) => data.to_selection(),
                Self::Message(data) => data.to_selection(),
                Self::MessageType(data) => data.to_selection(),
                Self::Session(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::UpdatedAt(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_session_data { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: crate :: db :: prisma_client :: session_data struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "session_id")] pub session_id : String , # [serde (rename = "role")] pub role : String , # [serde (rename = "message")] pub message : String , # [serde (rename = "message_type")] pub message_type : String , # [serde (rename = "created_at")] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "updated_at")] pub updated_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_session_data as partial_unchecked;
    #[derive(
        Debug,
        Clone,
        :: serde :: Serialize,
        :: serde :: Deserialize,
        :: prisma_client_rust :: specta :: Type,
    )]
    #[specta(rename = "SessionData", crate = "prisma_client_rust::specta")]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "session_id")]
        pub session_id: String,
        #[serde(rename = "role")]
        pub role: String,
        #[serde(rename = "message")]
        pub message: String,
        #[serde(rename = "message_type")]
        pub message_type: String,
        #[serde(
            rename = "session",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        #[specta(skip)]
        pub session: Option<Option<Box<super::session::Data>>>,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "updated_at")]
        pub updated_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    }
    impl Data {
        pub fn session(
            &self,
        ) -> Result<Option<&super::session::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.session
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(session),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Session(super::session::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Session(args) => {
                    let mut selections = < super :: session :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(session::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetSessionId(String),
        SetRole(String),
        SetMessage(String),
        SetMessageType(String),
        ConnectSession(super::session::UniqueWhereParam),
        DisconnectSession,
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetUpdatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetSessionId(value) => (
                    session_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetRole(value) => (
                    role::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetMessage(value) => (
                    message::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetMessageType(value) => (
                    message_type::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectSession(where_param) => (
                    session::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::session::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectSession => (
                    session::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetUpdatedAt(value) => (
                    updated_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        SessionId(String),
        Role(String),
        Message(String),
        MessageType(String),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        UpdatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::SessionId(value) => Self::SetSessionId(value),
                UncheckedSetParam::Role(value) => Self::SetRole(value),
                UncheckedSetParam::Message(value) => Self::SetMessage(value),
                UncheckedSetParam::MessageType(value) => Self::SetMessageType(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
                UncheckedSetParam::UpdatedAt(value) => Self::SetUpdatedAt(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        SessionId(::prisma_client_rust::Direction),
        Role(::prisma_client_rust::Direction),
        Message(::prisma_client_rust::Direction),
        MessageType(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        UpdatedAt(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::SessionId(direction) => (
                    session_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Role(direction) => (
                    role::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Message(direction) => (
                    message::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::MessageType(direction) => (
                    message_type::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::UpdatedAt(direction) => (
                    updated_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        SessionId(_prisma::read_filters::StringFilter),
        Role(_prisma::read_filters::StringFilter),
        Message(_prisma::read_filters::StringFilter),
        MessageType(_prisma::read_filters::StringFilter),
        SessionIsNull,
        SessionIs(Vec<super::session::WhereParam>),
        SessionIsNot(Vec<super::session::WhereParam>),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        UpdatedAt(_prisma::read_filters::DateTimeFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::SessionId(value) => (session_id::NAME, value.into()),
                Self::Role(value) => (role::NAME, value.into()),
                Self::Message(value) => (message::NAME, value.into()),
                Self::MessageType(value) => (message_type::NAME, value.into()),
                Self::SessionIsNull => (
                    session::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::SessionIs(where_params) => (
                    session::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SessionIsNot(where_params) => (
                    session::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
                Self::UpdatedAt(value) => (updated_at::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(session_id::NAME),
                ::prisma_client_rust::sel(role::NAME),
                ::prisma_client_rust::sel(message::NAME),
                ::prisma_client_rust::sel(message_type::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
                ::prisma_client_rust::sel(updated_at::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            session_id: String,
            role: String,
            message: String,
            message_type: String,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                session_id::set(session_id),
                role::set(role),
                message::set(message),
                message_type::set(message_type),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            session_id: String,
            role: String,
            message: String,
            message_type: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                session_id::set(session_id),
                role::set(role),
                message::set(message),
                message_type::set(message_type),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (session_id, role, message, message_type, mut _params): (
                String,
                String,
                String,
                String,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                session_id::set(session_id),
                role::set(role),
                message::set(message),
                message_type::set(message_type),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod session {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "Session";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Id, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod title {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "title";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTitle(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Title(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Title(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Title(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Title,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Title(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Title(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod prompt_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "prompt_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPromptId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::PromptId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::PromptId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::PromptId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            PromptId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementPromptId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementPromptId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyPromptId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DividePromptId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::PromptId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::PromptId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod with_context {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "with_context";
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetWithContext(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::WithContext(v)
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::WithContext(direction)
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::WithContext(_prisma::read_filters::BoolFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BoolFilter,
            WithContext,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::WithContext(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::WithContext(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod with_context_size {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "with_context_size";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetWithContextSize(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::WithContextSize(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::WithContextSize(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::WithContextSize(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            WithContextSize,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementWithContextSize(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementWithContextSize(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyWithContextSize(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideWithContextSize(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::WithContextSize(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::WithContextSize(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod session_model {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "session_model";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetSessionModel(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::SessionModel(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::SessionModel(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::SessionModel(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            SessionModel,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SessionModel(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SessionModel(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod session_data {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "session_data";
        pub struct Fetch(pub session_data::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<session_data::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: session_data::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: session_data::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::SessionData(v)
            }
        }
        pub fn fetch(params: Vec<session_data::WhereParam>) -> Fetch {
            Fetch(session_data::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<session_data::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectSessionData(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<session_data::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<session_data::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectSessionData(params)
        }
        pub fn set(params: Vec<session_data::UniqueWhereParam>) -> SetParam {
            SetParam::SetSessionData(params)
        }
        pub fn some(value: Vec<session_data::WhereParam>) -> WhereParam {
            WhereParam::SessionDataSome(value)
        }
        pub fn every(value: Vec<session_data::WhereParam>) -> WhereParam {
            WhereParam::SessionDataEvery(value)
        }
        pub fn none(value: Vec<session_data::WhereParam>) -> WhereParam {
            WhereParam::SessionDataNone(value)
        }
        pub enum Include {
            Select(session_data::ManyArgs, Vec<session_data::SelectParam>),
            Include(session_data::ManyArgs, Vec<session_data::IncludeParam>),
            Fetch(session_data::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SessionData(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < session_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < session_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: session_data::ManyArgs,
                nested_selections: Vec<session_data::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: session_data::ManyArgs,
                nested_selections: Vec<session_data::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(session_data::ManyArgs, Vec<session_data::SelectParam>),
            Include(session_data::ManyArgs, Vec<session_data::IncludeParam>),
            Fetch(session_data::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SessionData(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < session_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: session_data::ManyArgs,
                nested_selections: Vec<session_data::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: session_data::ManyArgs,
                nested_selections: Vec<session_data::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod updated_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "updated_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetUpdatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::UpdatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UpdatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::UpdatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            UpdatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UpdatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UpdatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub fn create(
        title: String,
        prompt_id: i32,
        with_context: bool,
        with_context_size: i32,
        session_model: String,
        _params: Vec<SetParam>,
    ) -> (String, i32, bool, i32, String, Vec<SetParam>) {
        (
            title,
            prompt_id,
            with_context,
            with_context_size,
            session_model,
            _params,
        )
    }
    pub fn create_unchecked(
        title: String,
        prompt_id: i32,
        with_context: bool,
        with_context_size: i32,
        session_model: String,
        _params: Vec<SetParam>,
    ) -> (String, i32, bool, i32, String, Vec<SetParam>) {
        (
            title,
            prompt_id,
            with_context,
            with_context_size,
            session_model,
            _params,
        )
    }
    #[macro_export]
    macro_rules ! _select_session { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: crate :: db :: prisma_client :: session :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: crate :: db :: prisma_client :: session :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: crate :: db :: prisma_client :: session :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: crate :: db :: prisma_client :: session :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: crate :: db :: prisma_client :: session :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: crate :: db :: prisma_client :: session :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , title , prompt_id , with_context , with_context_size , session_model , session_data , created_at , updated_at } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: crate :: db :: prisma_client :: session :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: crate :: db :: prisma_client :: session :: $ field :: NAME)] pub $ field : crate :: crate :: db :: prisma_client :: session :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: crate :: db :: prisma_client :: session :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: crate :: db :: prisma_client :: session :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: crate :: db :: prisma_client :: session :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: session :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: session :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "title" , "prompt_id" , "with_context" , "with_context_size" , "session_model" , "session_data" , "created_at" , "updated_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: crate :: db :: prisma_client :: session :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; title) => { String } ; (@ field_type ; prompt_id) => { i32 } ; (@ field_type ; with_context) => { bool } ; (@ field_type ; with_context_size) => { i32 } ; (@ field_type ; session_model) => { String } ; (@ field_type ; session_data : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < session_data :: Data > } ; (@ field_type ; session_data) => { Vec < crate :: crate :: db :: prisma_client :: session_data :: Data > } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; updated_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Session" , available relations are "id, title, prompt_id, with_context, with_context_size, session_model, session_data, created_at, updated_at")) } ; (@ field_module ; session_data : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: crate :: db :: prisma_client :: session_data :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: crate :: db :: prisma_client :: session :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: session :: id :: Select) } ; (@ selection_field_to_selection_param ; title) => { Into :: < crate :: crate :: db :: prisma_client :: session :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: session :: title :: Select) } ; (@ selection_field_to_selection_param ; prompt_id) => { Into :: < crate :: crate :: db :: prisma_client :: session :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: session :: prompt_id :: Select) } ; (@ selection_field_to_selection_param ; with_context) => { Into :: < crate :: crate :: db :: prisma_client :: session :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: session :: with_context :: Select) } ; (@ selection_field_to_selection_param ; with_context_size) => { Into :: < crate :: crate :: db :: prisma_client :: session :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: session :: with_context_size :: Select) } ; (@ selection_field_to_selection_param ; session_model) => { Into :: < crate :: crate :: db :: prisma_client :: session :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: session :: session_model :: Select) } ; (@ selection_field_to_selection_param ; session_data $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: crate :: db :: prisma_client :: session :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: session :: session_data :: Select :: $ selection_mode (crate :: crate :: db :: prisma_client :: session_data :: ManyArgs :: new (crate :: crate :: db :: prisma_client :: session_data :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: crate :: db :: prisma_client :: session_data :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; session_data $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: crate :: db :: prisma_client :: session :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: session :: session_data :: Select :: Fetch (crate :: crate :: db :: prisma_client :: session_data :: ManyArgs :: new (crate :: crate :: db :: prisma_client :: session_data :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: crate :: db :: prisma_client :: session :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: session :: created_at :: Select) } ; (@ selection_field_to_selection_param ; updated_at) => { Into :: < crate :: crate :: db :: prisma_client :: session :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: session :: updated_at :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: crate :: db :: prisma_client :: session :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; prompt_id) => { "prompt_id" } ; (@ field_serde_name ; with_context) => { "with_context" } ; (@ field_serde_name ; with_context_size) => { "with_context_size" } ; (@ field_serde_name ; session_model) => { "session_model" } ; (@ field_serde_name ; session_data) => { "session_data" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; updated_at) => { "updated_at" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
    pub use _select_session as select;
    pub enum SelectParam {
        Id(id::Select),
        Title(title::Select),
        PromptId(prompt_id::Select),
        WithContext(with_context::Select),
        WithContextSize(with_context_size::Select),
        SessionModel(session_model::Select),
        SessionData(session_data::Select),
        CreatedAt(created_at::Select),
        UpdatedAt(updated_at::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Title(data) => data.to_selection(),
                Self::PromptId(data) => data.to_selection(),
                Self::WithContext(data) => data.to_selection(),
                Self::WithContextSize(data) => data.to_selection(),
                Self::SessionModel(data) => data.to_selection(),
                Self::SessionData(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::UpdatedAt(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_session { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: crate :: db :: prisma_client :: session :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: crate :: db :: prisma_client :: session :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: crate :: db :: prisma_client :: session :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: crate :: db :: prisma_client :: session :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: crate :: db :: prisma_client :: session :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: crate :: db :: prisma_client :: session :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: crate :: db :: prisma_client :: session :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: crate :: db :: prisma_client :: session :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { session_data } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: crate :: db :: prisma_client :: session :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: session :: id :: NAME)] pub id : String , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: session :: title :: NAME)] pub title : String , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: session :: prompt_id :: NAME)] pub prompt_id : i32 , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: session :: with_context :: NAME)] pub with_context : bool , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: session :: with_context_size :: NAME)] pub with_context_size : i32 , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: session :: session_model :: NAME)] pub session_model : String , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: session :: created_at :: NAME)] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: session :: updated_at :: NAME)] pub updated_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (# [specta (rename_from_path = crate :: crate :: db :: prisma_client :: session :: $ field :: NAME)] pub $ field : crate :: crate :: db :: prisma_client :: session :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (title) , stringify ! (prompt_id) , stringify ! (with_context) , stringify ! (with_context_size) , stringify ! (session_model) , stringify ! (created_at) , stringify ! (updated_at)] . len ()) ? ; $ (state . serialize_field (crate :: crate :: db :: prisma_client :: session :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: crate :: db :: prisma_client :: session :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: session :: title :: NAME , & self . title) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: session :: prompt_id :: NAME , & self . prompt_id) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: session :: with_context :: NAME , & self . with_context) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: session :: with_context_size :: NAME , & self . with_context_size) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: session :: session_model :: NAME , & self . session_model) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: session :: created_at :: NAME , & self . created_at) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: session :: updated_at :: NAME , & self . updated_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , title , prompt_id , with_context , with_context_size , session_model , created_at , updated_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: crate :: db :: prisma_client :: session :: $ field :: NAME) , + , crate :: crate :: db :: prisma_client :: session :: id :: NAME , crate :: crate :: db :: prisma_client :: session :: title :: NAME , crate :: crate :: db :: prisma_client :: session :: prompt_id :: NAME , crate :: crate :: db :: prisma_client :: session :: with_context :: NAME , crate :: crate :: db :: prisma_client :: session :: with_context_size :: NAME , crate :: crate :: db :: prisma_client :: session :: session_model :: NAME , crate :: crate :: db :: prisma_client :: session :: created_at :: NAME , crate :: crate :: db :: prisma_client :: session :: updated_at :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: crate :: db :: prisma_client :: session :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: crate :: db :: prisma_client :: session :: id :: NAME => Ok (Field :: id) , crate :: crate :: db :: prisma_client :: session :: title :: NAME => Ok (Field :: title) , crate :: crate :: db :: prisma_client :: session :: prompt_id :: NAME => Ok (Field :: prompt_id) , crate :: crate :: db :: prisma_client :: session :: with_context :: NAME => Ok (Field :: with_context) , crate :: crate :: db :: prisma_client :: session :: with_context_size :: NAME => Ok (Field :: with_context_size) , crate :: crate :: db :: prisma_client :: session :: session_model :: NAME => Ok (Field :: session_model) , crate :: crate :: db :: prisma_client :: session :: created_at :: NAME => Ok (Field :: created_at) , crate :: crate :: db :: prisma_client :: session :: updated_at :: NAME => Ok (Field :: updated_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut title = None ; let mut prompt_id = None ; let mut with_context = None ; let mut with_context_size = None ; let mut session_model = None ; let mut created_at = None ; let mut updated_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: session :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: title => { if title . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: session :: title :: NAME)) ; } title = Some (map . next_value () ?) ; } Field :: prompt_id => { if prompt_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: session :: prompt_id :: NAME)) ; } prompt_id = Some (map . next_value () ?) ; } Field :: with_context => { if with_context . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: session :: with_context :: NAME)) ; } with_context = Some (map . next_value () ?) ; } Field :: with_context_size => { if with_context_size . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: session :: with_context_size :: NAME)) ; } with_context_size = Some (map . next_value () ?) ; } Field :: session_model => { if session_model . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: session :: session_model :: NAME)) ; } session_model = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: session :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } Field :: updated_at => { if updated_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: session :: updated_at :: NAME)) ; } updated_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: session :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: session :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: session :: id :: NAME)) ? ; let title = title . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: session :: title :: NAME)) ? ; let prompt_id = prompt_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: session :: prompt_id :: NAME)) ? ; let with_context = with_context . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: session :: with_context :: NAME)) ? ; let with_context_size = with_context_size . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: session :: with_context_size :: NAME)) ? ; let session_model = session_model . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: session :: session_model :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: session :: created_at :: NAME)) ? ; let updated_at = updated_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: session :: updated_at :: NAME)) ? ; Ok (Data { id , title , prompt_id , with_context , with_context_size , session_model , created_at , updated_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "title" , "prompt_id" , "with_context" , "with_context_size" , "session_model" , "session_data" , "created_at" , "updated_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: crate :: db :: prisma_client :: session :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; session_data : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < session_data :: Data > } ; (@ field_type ; session_data) => { Vec < crate :: crate :: db :: prisma_client :: session_data :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Session" , available relations are "session_data")) } ; (@ field_module ; session_data : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: crate :: db :: prisma_client :: session_data :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; session_data $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: crate :: db :: prisma_client :: session :: IncludeParam > :: into (crate :: crate :: db :: prisma_client :: session :: session_data :: Include :: $ selection_mode (crate :: crate :: db :: prisma_client :: session_data :: ManyArgs :: new (crate :: crate :: db :: prisma_client :: session_data :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: crate :: db :: prisma_client :: session_data :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; session_data $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: crate :: db :: prisma_client :: session :: IncludeParam > :: into (crate :: crate :: db :: prisma_client :: session :: session_data :: Include :: Fetch (crate :: crate :: db :: prisma_client :: session_data :: ManyArgs :: new (crate :: crate :: db :: prisma_client :: session_data :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: crate :: db :: prisma_client :: session :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; prompt_id) => { "prompt_id" } ; (@ field_serde_name ; with_context) => { "with_context" } ; (@ field_serde_name ; with_context_size) => { "with_context_size" } ; (@ field_serde_name ; session_model) => { "session_model" } ; (@ field_serde_name ; session_data) => { "session_data" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; updated_at) => { "updated_at" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
    pub use _include_session as include;
    pub enum IncludeParam {
        Id(id::Include),
        Title(title::Include),
        PromptId(prompt_id::Include),
        WithContext(with_context::Include),
        WithContextSize(with_context_size::Include),
        SessionModel(session_model::Include),
        SessionData(session_data::Include),
        CreatedAt(created_at::Include),
        UpdatedAt(updated_at::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Title(data) => data.to_selection(),
                Self::PromptId(data) => data.to_selection(),
                Self::WithContext(data) => data.to_selection(),
                Self::WithContextSize(data) => data.to_selection(),
                Self::SessionModel(data) => data.to_selection(),
                Self::SessionData(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::UpdatedAt(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_session { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: crate :: db :: prisma_client :: session struct $ struct_name { # [serde (rename = "id")] pub id : String , # [serde (rename = "title")] pub title : String , # [serde (rename = "prompt_id")] pub prompt_id : i32 , # [serde (rename = "with_context")] pub with_context : bool , # [serde (rename = "with_context_size")] pub with_context_size : i32 , # [serde (rename = "session_model")] pub session_model : String , # [serde (rename = "created_at")] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "updated_at")] pub updated_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_session as partial_unchecked;
    #[derive(
        Debug,
        Clone,
        :: serde :: Serialize,
        :: serde :: Deserialize,
        :: prisma_client_rust :: specta :: Type,
    )]
    #[specta(rename = "Session", crate = "prisma_client_rust::specta")]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "title")]
        pub title: String,
        #[serde(rename = "prompt_id")]
        pub prompt_id: i32,
        #[serde(rename = "with_context")]
        pub with_context: bool,
        #[serde(rename = "with_context_size")]
        pub with_context_size: i32,
        #[serde(rename = "session_model")]
        pub session_model: String,
        #[serde(rename = "session_data")]
        #[specta(skip)]
        pub session_data: Option<Vec<super::session_data::Data>>,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "updated_at")]
        pub updated_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    }
    impl Data {
        pub fn session_data(
            &self,
        ) -> Result<&Vec<super::session_data::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.session_data
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(session_data),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        SessionData(super::session_data::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::SessionData(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: session_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        session_data::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(String),
        SetTitle(String),
        SetPromptId(i32),
        IncrementPromptId(i32),
        DecrementPromptId(i32),
        MultiplyPromptId(i32),
        DividePromptId(i32),
        SetWithContext(bool),
        SetWithContextSize(i32),
        IncrementWithContextSize(i32),
        DecrementWithContextSize(i32),
        MultiplyWithContextSize(i32),
        DivideWithContextSize(i32),
        SetSessionModel(String),
        ConnectSessionData(Vec<super::session_data::UniqueWhereParam>),
        DisconnectSessionData(Vec<super::session_data::UniqueWhereParam>),
        SetSessionData(Vec<super::session_data::UniqueWhereParam>),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetUpdatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetTitle(value) => (
                    title::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetPromptId(value) => (
                    prompt_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementPromptId(value) => (
                    prompt_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementPromptId(value) => (
                    prompt_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyPromptId(value) => (
                    prompt_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DividePromptId(value) => (
                    prompt_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetWithContext(value) => (
                    with_context::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetWithContextSize(value) => (
                    with_context_size::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementWithContextSize(value) => (
                    with_context_size::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementWithContextSize(value) => (
                    with_context_size::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyWithContextSize(value) => (
                    with_context_size::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideWithContextSize(value) => (
                    with_context_size::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetSessionModel(value) => (
                    session_model::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectSessionData(where_params) => (
                    session_data::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::session_data::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectSessionData(where_params) => (
                    session_data::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::session_data::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetSessionData(where_params) => (
                    session_data::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::session_data::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetUpdatedAt(value) => (
                    updated_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(String),
        Title(String),
        PromptId(i32),
        WithContext(bool),
        WithContextSize(i32),
        SessionModel(String),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        UpdatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::Title(value) => Self::SetTitle(value),
                UncheckedSetParam::PromptId(value) => Self::SetPromptId(value),
                UncheckedSetParam::WithContext(value) => Self::SetWithContext(value),
                UncheckedSetParam::WithContextSize(value) => Self::SetWithContextSize(value),
                UncheckedSetParam::SessionModel(value) => Self::SetSessionModel(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
                UncheckedSetParam::UpdatedAt(value) => Self::SetUpdatedAt(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Title(::prisma_client_rust::Direction),
        PromptId(::prisma_client_rust::Direction),
        WithContext(::prisma_client_rust::Direction),
        WithContextSize(::prisma_client_rust::Direction),
        SessionModel(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        UpdatedAt(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Title(direction) => (
                    title::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::PromptId(direction) => (
                    prompt_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::WithContext(direction) => (
                    with_context::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::WithContextSize(direction) => (
                    with_context_size::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::SessionModel(direction) => (
                    session_model::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::UpdatedAt(direction) => (
                    updated_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::StringFilter),
        Title(_prisma::read_filters::StringFilter),
        PromptId(_prisma::read_filters::IntFilter),
        WithContext(_prisma::read_filters::BoolFilter),
        WithContextSize(_prisma::read_filters::IntFilter),
        SessionModel(_prisma::read_filters::StringFilter),
        SessionDataSome(Vec<super::session_data::WhereParam>),
        SessionDataEvery(Vec<super::session_data::WhereParam>),
        SessionDataNone(Vec<super::session_data::WhereParam>),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        UpdatedAt(_prisma::read_filters::DateTimeFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Title(value) => (title::NAME, value.into()),
                Self::PromptId(value) => (prompt_id::NAME, value.into()),
                Self::WithContext(value) => (with_context::NAME, value.into()),
                Self::WithContextSize(value) => (with_context_size::NAME, value.into()),
                Self::SessionModel(value) => (session_model::NAME, value.into()),
                Self::SessionDataSome(where_params) => (
                    session_data::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SessionDataEvery(where_params) => (
                    session_data::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SessionDataNone(where_params) => (
                    session_data::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
                Self::UpdatedAt(value) => (updated_at::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::StringFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(title::NAME),
                ::prisma_client_rust::sel(prompt_id::NAME),
                ::prisma_client_rust::sel(with_context::NAME),
                ::prisma_client_rust::sel(with_context_size::NAME),
                ::prisma_client_rust::sel(session_model::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
                ::prisma_client_rust::sel(updated_at::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            title: String,
            prompt_id: i32,
            with_context: bool,
            with_context_size: i32,
            session_model: String,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                title::set(title),
                prompt_id::set(prompt_id),
                with_context::set(with_context),
                with_context_size::set(with_context_size),
                session_model::set(session_model),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            title: String,
            prompt_id: i32,
            with_context: bool,
            with_context_size: i32,
            session_model: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                title::set(title),
                prompt_id::set(prompt_id),
                with_context::set(with_context),
                with_context_size::set(with_context_size),
                session_model::set(session_model),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (title, prompt_id, with_context, with_context_size, session_model, mut _params): (
                String,
                i32,
                bool,
                i32,
                String,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                title::set(title),
                prompt_id::set(prompt_id),
                with_context::set(with_context),
                with_context_size::set(with_context_size),
                session_model::set(session_model),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod settings {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "Settings";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod key {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "key";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetKey(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Key(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Key(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::KeyEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Key, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Key(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Key(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod value {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "value";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetValue(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Value(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Value(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Value(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Value,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Value(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Value(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod updated_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "updated_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetUpdatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::UpdatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UpdatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::UpdatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            UpdatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UpdatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UpdatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub fn create(
        key: String,
        value: String,
        _params: Vec<SetParam>,
    ) -> (String, String, Vec<SetParam>) {
        (key, value, _params)
    }
    pub fn create_unchecked(
        key: String,
        value: String,
        _params: Vec<SetParam>,
    ) -> (String, String, Vec<SetParam>) {
        (key, value, _params)
    }
    #[macro_export]
    macro_rules ! _select_settings { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: crate :: db :: prisma_client :: settings :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: crate :: db :: prisma_client :: settings :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: crate :: db :: prisma_client :: settings :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: crate :: db :: prisma_client :: settings :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: crate :: db :: prisma_client :: settings :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: crate :: db :: prisma_client :: settings :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , key , value , created_at , updated_at } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: crate :: db :: prisma_client :: settings :: select ! (@ specta_data_struct ; pub struct Data { $ (# [specta (rename_from_path = crate :: crate :: db :: prisma_client :: settings :: $ field :: NAME)] pub $ field : crate :: crate :: db :: prisma_client :: settings :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: crate :: db :: prisma_client :: settings :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: crate :: db :: prisma_client :: settings :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: crate :: db :: prisma_client :: settings :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: settings :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: settings :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "key" , "value" , "created_at" , "updated_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: crate :: db :: prisma_client :: settings :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; key) => { String } ; (@ field_type ; value) => { String } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; updated_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Settings" , available relations are "id, key, value, created_at, updated_at")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: crate :: db :: prisma_client :: settings :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: settings :: id :: Select) } ; (@ selection_field_to_selection_param ; key) => { Into :: < crate :: crate :: db :: prisma_client :: settings :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: settings :: key :: Select) } ; (@ selection_field_to_selection_param ; value) => { Into :: < crate :: crate :: db :: prisma_client :: settings :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: settings :: value :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: crate :: db :: prisma_client :: settings :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: settings :: created_at :: Select) } ; (@ selection_field_to_selection_param ; updated_at) => { Into :: < crate :: crate :: db :: prisma_client :: settings :: SelectParam > :: into (crate :: crate :: db :: prisma_client :: settings :: updated_at :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: crate :: db :: prisma_client :: settings :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; key) => { "key" } ; (@ field_serde_name ; value) => { "value" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; updated_at) => { "updated_at" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
    pub use _select_settings as select;
    pub enum SelectParam {
        Id(id::Select),
        Key(key::Select),
        Value(value::Select),
        CreatedAt(created_at::Select),
        UpdatedAt(updated_at::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Key(data) => data.to_selection(),
                Self::Value(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::UpdatedAt(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_settings { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: crate :: db :: prisma_client :: settings :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: crate :: db :: prisma_client :: settings :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: crate :: db :: prisma_client :: settings :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: crate :: db :: prisma_client :: settings :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: crate :: db :: prisma_client :: settings :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: crate :: db :: prisma_client :: settings :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: crate :: db :: prisma_client :: settings :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: crate :: db :: prisma_client :: settings :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } const SPECTA_TYPE_NAME : & 'static str = prisma_client_rust :: macros :: to_pascal_case ! ($ ($ module_name) ?) ; crate :: crate :: db :: prisma_client :: settings :: include ! (@ specta_data_struct ; pub struct Data { # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: settings :: id :: NAME)] pub id : i32 , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: settings :: key :: NAME)] pub key : String , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: settings :: value :: NAME)] pub value : String , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: settings :: created_at :: NAME)] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [specta (rename_from_path = crate :: crate :: db :: prisma_client :: settings :: updated_at :: NAME)] pub updated_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (# [specta (rename_from_path = crate :: crate :: db :: prisma_client :: settings :: $ field :: NAME)] pub $ field : crate :: crate :: db :: prisma_client :: settings :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } ; $ ($ module_name) ?) ; impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (key) , stringify ! (value) , stringify ! (created_at) , stringify ! (updated_at)] . len ()) ? ; $ (state . serialize_field (crate :: crate :: db :: prisma_client :: settings :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: crate :: db :: prisma_client :: settings :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: settings :: key :: NAME , & self . key) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: settings :: value :: NAME , & self . value) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: settings :: created_at :: NAME , & self . created_at) ? ; state . serialize_field (crate :: crate :: db :: prisma_client :: settings :: updated_at :: NAME , & self . updated_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , key , value , created_at , updated_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: crate :: db :: prisma_client :: settings :: $ field :: NAME) , + , crate :: crate :: db :: prisma_client :: settings :: id :: NAME , crate :: crate :: db :: prisma_client :: settings :: key :: NAME , crate :: crate :: db :: prisma_client :: settings :: value :: NAME , crate :: crate :: db :: prisma_client :: settings :: created_at :: NAME , crate :: crate :: db :: prisma_client :: settings :: updated_at :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: crate :: db :: prisma_client :: settings :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: crate :: db :: prisma_client :: settings :: id :: NAME => Ok (Field :: id) , crate :: crate :: db :: prisma_client :: settings :: key :: NAME => Ok (Field :: key) , crate :: crate :: db :: prisma_client :: settings :: value :: NAME => Ok (Field :: value) , crate :: crate :: db :: prisma_client :: settings :: created_at :: NAME => Ok (Field :: created_at) , crate :: crate :: db :: prisma_client :: settings :: updated_at :: NAME => Ok (Field :: updated_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut key = None ; let mut value = None ; let mut created_at = None ; let mut updated_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: settings :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: key => { if key . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: settings :: key :: NAME)) ; } key = Some (map . next_value () ?) ; } Field :: value => { if value . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: settings :: value :: NAME)) ; } value = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: settings :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } Field :: updated_at => { if updated_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: settings :: updated_at :: NAME)) ; } updated_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: db :: prisma_client :: settings :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: settings :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: settings :: id :: NAME)) ? ; let key = key . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: settings :: key :: NAME)) ? ; let value = value . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: settings :: value :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: settings :: created_at :: NAME)) ? ; let updated_at = updated_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: db :: prisma_client :: settings :: updated_at :: NAME)) ? ; Ok (Data { id , key , value , created_at , updated_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "key" , "value" , "created_at" , "updated_at"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: crate :: db :: prisma_client :: settings :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Settings" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: crate :: db :: prisma_client :: settings :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; key) => { "key" } ; (@ field_serde_name ; value) => { "value" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; updated_at) => { "updated_at" } ; (@ specta_data_struct ; $ struct : item ;) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] # [specta (inline)] $ struct } ; (@ specta_data_struct ; $ struct : item ; $ name : ident) => { # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] # [derive (:: prisma_client_rust :: specta :: Type)] # [specta (rename_from_path = SPECTA_TYPE_NAME , crate = "prisma_client_rust::specta")] $ struct } ; }
    pub use _include_settings as include;
    pub enum IncludeParam {
        Id(id::Include),
        Key(key::Include),
        Value(value::Include),
        CreatedAt(created_at::Include),
        UpdatedAt(updated_at::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Key(data) => data.to_selection(),
                Self::Value(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::UpdatedAt(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_settings { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: crate :: db :: prisma_client :: settings struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "key")] pub key : String , # [serde (rename = "value")] pub value : String , # [serde (rename = "created_at")] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "updated_at")] pub updated_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_settings as partial_unchecked;
    #[derive(
        Debug,
        Clone,
        :: serde :: Serialize,
        :: serde :: Deserialize,
        :: prisma_client_rust :: specta :: Type,
    )]
    #[specta(rename = "Settings", crate = "prisma_client_rust::specta")]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "key")]
        pub key: String,
        #[serde(rename = "value")]
        pub value: String,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "updated_at")]
        pub updated_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetKey(String),
        SetValue(String),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetUpdatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetKey(value) => (
                    key::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetValue(value) => (
                    value::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetUpdatedAt(value) => (
                    updated_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        Key(String),
        Value(String),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        UpdatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::Key(value) => Self::SetKey(value),
                UncheckedSetParam::Value(value) => Self::SetValue(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
                UncheckedSetParam::UpdatedAt(value) => Self::SetUpdatedAt(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Key(::prisma_client_rust::Direction),
        Value(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        UpdatedAt(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Key(direction) => (
                    key::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Value(direction) => (
                    value::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::UpdatedAt(direction) => (
                    updated_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        Key(_prisma::read_filters::StringFilter),
        Value(_prisma::read_filters::StringFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        UpdatedAt(_prisma::read_filters::DateTimeFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Key(value) => (key::NAME, value.into()),
                Self::Value(value) => (value::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
                Self::UpdatedAt(value) => (updated_at::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        KeyEquals(String),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::KeyEquals(value) => {
                    Self::Key(_prisma::read_filters::StringFilter::Equals(value))
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(key::NAME),
                ::prisma_client_rust::sel(value::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
                ::prisma_client_rust::sel(updated_at::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(self, key: String, value: String, mut _params: Vec<SetParam>) -> Create<'a> {
            _params.extend([key::set(key), value::set(value)]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            key: String,
            value: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([key::set(key), value::set(value)]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (key, value, mut _params): (String, String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([key::set(key), value::set(value)]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod _prisma {
    pub struct PrismaClientBuilder {
        url: Option<String>,
        action_notifier: ::prisma_client_rust::ActionNotifier,
    }
    impl PrismaClientBuilder {
        fn new() -> Self {
            Self {
                url: None,
                action_notifier: ::prisma_client_rust::ActionNotifier::new(),
            }
        }
        pub fn with_url(mut self, url: String) -> Self {
            self.url = Some(url);
            self
        }
        pub async fn build(self) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
            let internals = ::prisma_client_rust::PrismaClientInternals::new(
                self.url,
                self.action_notifier,
                super::DATAMODEL_STR,
            )
            .await?;
            Ok(PrismaClient(internals))
        }
    }
    pub struct PrismaClient(::prisma_client_rust::PrismaClientInternals);
    impl ::std::fmt::Debug for PrismaClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.debug_struct("PrismaClient").finish()
        }
    }
    impl PrismaClient {
        pub fn _builder() -> PrismaClientBuilder {
            PrismaClientBuilder::new()
        }
        pub fn _query_raw<T: ::prisma_client_rust::Data>(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::QueryRaw<T> {
            ::prisma_client_rust::QueryRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub fn _execute_raw(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::ExecuteRaw {
            ::prisma_client_rust::ExecuteRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub async fn _batch<
            'batch,
            T: ::prisma_client_rust::BatchContainer<'batch, Marker>,
            Marker,
        >(
            &self,
            queries: T,
        ) -> ::prisma_client_rust::Result<
            <T as ::prisma_client_rust::BatchContainer<'batch, Marker>>::ReturnType,
        > {
            ::prisma_client_rust::batch(queries, &self.0).await
        }
        pub fn _transaction(&self) -> ::prisma_client_rust::TransactionBuilder<Self> {
            ::prisma_client_rust::TransactionBuilder::_new(self, &self.0)
        }
        pub async fn _migrate_deploy(
            &self,
        ) -> Result<(), ::prisma_client_rust::migrations::MigrateDeployError> {
            let res = ::prisma_client_rust::migrations::migrate_deploy(
                super::DATAMODEL_STR,
                super::MIGRATIONS_DIR,
                &self.0.url(),
            )
            .await;
            ::prisma_client_rust::tokio::time::sleep(core::time::Duration::from_millis(1)).await;
            res
        }
        pub async fn _migrate_resolve(
            &self,
            migration: &str,
        ) -> Result<(), ::prisma_client_rust::migrations::MigrateResolveError> {
            ::prisma_client_rust::migrations::migrate_resolve(
                migration,
                super::DATAMODEL_STR,
                super::MIGRATIONS_DIR,
                &self.0.url(),
            )
            .await
        }
        pub fn _db_push(&self) -> ::prisma_client_rust::migrations::DbPush {
            ::prisma_client_rust::migrations::db_push(super::DATAMODEL_STR, &self.0.url())
        }
        pub fn prompt(&self) -> super::prompt::Actions {
            super::prompt::Actions { client: &self.0 }
        }
        pub fn session_data(&self) -> super::session_data::Actions {
            super::session_data::Actions { client: &self.0 }
        }
        pub fn session(&self) -> super::session::Actions {
            super::session::Actions { client: &self.0 }
        }
        pub fn settings(&self) -> super::settings::Actions {
            super::settings::Actions { client: &self.0 }
        }
    }
    impl ::prisma_client_rust::PrismaClient for PrismaClient {
        fn internals(&self) -> &::prisma_client_rust::PrismaClientInternals {
            &self.0
        }
        fn internals_mut(&mut self) -> &mut ::prisma_client_rust::PrismaClientInternals {
            &mut self.0
        }
        fn with_tx_id(&self, tx_id: Option<::prisma_client_rust::query_core::TxId>) -> Self {
            Self(self.0.with_tx_id(tx_id))
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum PromptScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "title")]
        Title,
        #[serde(rename = "desc")]
        Desc,
        #[serde(rename = "system")]
        System,
        #[serde(rename = "favorite")]
        Favorite,
        #[serde(rename = "actived")]
        Actived,
        #[serde(rename = "with_context")]
        WithContext,
        #[serde(rename = "with_context_size")]
        WithContextSize,
        #[serde(rename = "max_tokens")]
        MaxTokens,
        #[serde(rename = "top_p")]
        TopP,
        #[serde(rename = "temperature")]
        Temperature,
        #[serde(rename = "opts")]
        Opts,
        #[serde(rename = "prehandle_script")]
        PrehandleScript,
        #[serde(rename = "labels")]
        Labels,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "updated_at")]
        UpdatedAt,
    }
    impl ToString for PromptScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Title => "title".to_string(),
                Self::Desc => "desc".to_string(),
                Self::System => "system".to_string(),
                Self::Favorite => "favorite".to_string(),
                Self::Actived => "actived".to_string(),
                Self::WithContext => "with_context".to_string(),
                Self::WithContextSize => "with_context_size".to_string(),
                Self::MaxTokens => "max_tokens".to_string(),
                Self::TopP => "top_p".to_string(),
                Self::Temperature => "temperature".to_string(),
                Self::Opts => "opts".to_string(),
                Self::PrehandleScript => "prehandle_script".to_string(),
                Self::Labels => "labels".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::UpdatedAt => "updated_at".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum SessionDataScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "session_id")]
        SessionId,
        #[serde(rename = "role")]
        Role,
        #[serde(rename = "message")]
        Message,
        #[serde(rename = "message_type")]
        MessageType,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "updated_at")]
        UpdatedAt,
    }
    impl ToString for SessionDataScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::SessionId => "session_id".to_string(),
                Self::Role => "role".to_string(),
                Self::Message => "message".to_string(),
                Self::MessageType => "message_type".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::UpdatedAt => "updated_at".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum SessionScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "title")]
        Title,
        #[serde(rename = "prompt_id")]
        PromptId,
        #[serde(rename = "with_context")]
        WithContext,
        #[serde(rename = "with_context_size")]
        WithContextSize,
        #[serde(rename = "session_model")]
        SessionModel,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "updated_at")]
        UpdatedAt,
    }
    impl ToString for SessionScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Title => "title".to_string(),
                Self::PromptId => "prompt_id".to_string(),
                Self::WithContext => "with_context".to_string(),
                Self::WithContextSize => "with_context_size".to_string(),
                Self::SessionModel => "session_model".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::UpdatedAt => "updated_at".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum SettingsScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "key")]
        Key,
        #[serde(rename = "value")]
        Value,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "updated_at")]
        UpdatedAt,
    }
    impl ToString for SettingsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Key => "key".to_string(),
                Self::Value => "value".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::UpdatedAt => "updated_at".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum SortOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }
    impl ToString for SortOrder {
        fn to_string(&self) -> String {
            match self {
                Self::Asc => "asc".to_string(),
                Self::Desc => "desc".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum TransactionIsolationLevel {
        #[serde(rename = "Serializable")]
        Serializable,
    }
    impl ToString for TransactionIsolationLevel {
        fn to_string(&self) -> String {
            match self {
                Self::Serializable => "Serializable".to_string(),
            }
        }
    }
    impl ::prisma_client_rust::TransactionIsolationLevel for TransactionIsolationLevel {}
    pub mod read_filters {
        #[derive(Clone)]
        pub enum IntFilter {
            Equals(i32),
            InVec(Vec<i32>),
            NotInVec(Vec<i32>),
            Lt(i32),
            Lte(i32),
            Gt(i32),
            Gte(i32),
            Not(i32),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for IntFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Int(value as i64),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum StringFilter {
            Equals(String),
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Not(String),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Contains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::EndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "endsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum BoolFilter {
            Equals(bool),
            Not(bool),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for BoolFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Boolean(value),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum DateTimeFilter {
            Equals(
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            ),
            InVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            NotInVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            Lt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Lte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Not(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for DateTimeFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::DateTime(value),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                }
            }
        }
    }
}
pub use _prisma::*;
